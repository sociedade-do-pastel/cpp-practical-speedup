* Motivação

A criação deste pseudo /profiler/ se dá por conta da necessidade de *automatizar* o estudo do comportamento do problema apresentado anteriormente (ocorrências de números primos num arquivo com duzentos e cinquenta mil números). Basicamente, foi pedido que testes sobre uma quantidade de /threads/ seja feito *cinquenta vezes* de forma que seja possível retirar a média destes tempos obtidos para que, por fim, sejam utilizados nos cálculos/gráficos necessários.

** Como este relatório é estruturado

O /core/ do programa foi escrito em C++, compilado com o /GNU C compiler/ com as devidas bibliotecas importadas, no caso, apenas ~pthread~. O comando de compilação pode ser encontrado no [[file:Makefile][Makefile]] encontrado na raiz do projeto.

O /wrapper/ para contagem dos tempos é escrito em *Common Lisp*, executado a partir da implementação *SBCL*.

* O programa principal

O programa deve ser executado sem argumentos para que este assuma um comportamento *serial* ou com um número inteiro *n* onde \( n > 1\) para que este seja executado com *n* /threads/.

* O /wrapper/
:PROPERTIES:
:header-args: :tangle profilero.lisp
:END:

O procedimento mais simples é a execução do programa com nome e parâmetros definidos dinamicamente

#+begin_src lisp
(defvar *program-name* "Primos")
(defvar *program-control-string* "./~a --qt-threads=~a --output=~a")
#+end_src

#+RESULTS:
: *PROGRAM-CONTROL-STRING*

#+begin_src lisp 
(defun execute-program (&optional n)
  "Executes the program defined at top level, while checking if it exists.
It will always execute it passing ``n'' as an argument and 0 in order to silence
its output"
  (if (uiop:file-exists-p *program-name*)
      (read-from-string
       (uiop:run-program (format nil *program-control-string* *program-name* n 0 )
			 :output :string))
      (error "You should compile Main.cpp")))
#+end_src

** Cálculo da média 

O programa será executado cinquenta vezes para que seja definida uma média simples em relação a todas as execuções. Para que seja possível um controle maior, o número de execuções será customizável.

#+begin_src lisp
(defparameter *total-runs* 50)
#+end_src

#+RESULTS:
: *TOTAL-RUNS*

#+begin_src lisp 
(defun get-average (runs &optional (n 1))
  "Runs the program x times (runs) and returns the average runtime (sum/runs).
``n'' refers to the number of threads in which our program must execute on."
  (loop for i
	from 0 below runs
	sum (execute-program n) into result
	finally (return (/ result runs))))

#+end_src

#+RESULTS:
: GET-AVERAGE

** Cálculo do /Speedup/

Partindo do cálculo simples do /Speedup/ onde \(Speedup = \frac{T_1}{T_n}\), podemos
definir a seguinte função:

#+begin_src lisp 
(defun get-speedup (serial-time threaded-time)
  "Returns the speedup (``serial-time''/``threaded-time'') of a process/job."
  (/ serial-time threaded-time))
#+end_src

#+RESULTS:
: GET-SPEEDUP

** Coletando os dados das execuções

Por motivos de simplificação do experimento atual, algumas assunções devem ser realizadas quanto ao ambiente em que tais experiências serão realizadas

1. \(x = [1, \infty[ \), como a equipe não possui infinitas quantidades de CPUs, o limite superior será o número de CPUs dos membros da equipe;
2. Quando \(x = 1\), o comportamento do programa será completamente *serial*;
3. Assumindo que /n/ seja o número de /threads/, o cálculo de /Speedup/ se torna mais impreciso quando \(n > x\), uma vez que, num mundo ideal sem troca de contexto com todas as CPUs ocupadas com uma /thread/, \( n - x \) /threads/ ficarão *no estado ready*.


#+begin_src lisp
(defparameter *cpu-count* 5)
#+end_src

#+RESULTS:
: *CPU-COUNT*

Após execução será produzida uma tabela cujas colunas representam:

1. Número de /threads n/
2. Tempo em milissegundos da execução
3. /Speedup/



#+begin_src lisp
(defun get-row (n &key serial)
  "Returns a single row of our table.
Having the number of threads to execute the main program being ``n'',
this procedure will return a list with the following structure:

(number-of-threads (average-time . speedup))

The optional keyword argument, ``serial'' tells us that the serial time was
supplied, otherwise the average time will be divided by itself in order to
obtain speedup info"
  (let* ((time (get-average *total-runs* n))
	 (speedup (get-speedup (or serial time) time)))
    (list n time speedup)))
#+end_src

#+RESULTS:
: GET-ROW


E por fim, a função "principal".

#+begin_src lisp
(defun produce-table ()
  "Produces the main table to be read by org."
  (let* ((serial-row (get-row 1))
	 (serial-time (second serial-row))
	 (parallel-table (loop for n from 2 to *cpu-count*
			       collect (get-row n :serial serial-time ))))
    (cons serial-row parallel-table)))
#+end_src

#+RESULTS:
: PRODUCE-TABLE

Após executá-la, temos os seguintes resultados:

#+begin_src lisp :exports both
(produce-table)
#+end_src

#+RESULTS:
#+PLOT: set:"xlabel 'CPUs'" set:"ylabel 'Tempo médio (ms)'" set:"xtics 1"
#+PLOT: title:"Speedup com paralelismo" ind:1 :deps(2 3) type:2d with:lines
#+PLOT: labels:("New label" "Speedup" "")
#+PLOT: set:"output './speedup-graph.png'" set:"terminal png size 600,300"
|------+-------------+-----------|
| CPUs | Tempo médio |   Speedup |
|------+-------------+-----------|
|    1 |   5849.1343 |       1.0 |
|    2 |     3540.78 | 1.6519338 |
|    3 |   3513.6194 | 1.6647035 |
|    4 |   3037.8044 |  1.925448 |
|    5 |   3196.9824 | 1.8295797 |

** O gráfico

[[file:speedup-graph.png]]


